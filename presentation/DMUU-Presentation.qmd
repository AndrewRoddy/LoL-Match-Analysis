---
title: "League of Legends Match Analysis"
author: "Logan Senol, Caleb Stanberry, Andrew Roddy"
# format: html # Test Mode
format: 
    revealjs: # Present Mode
        theme: [default, styles.scss]
        auto-stretch: true
---

## League of Legends Crash Course {.center}

What is League of Legends?


![Also known as "League" and "LoL".](img/lol-logo.png){width="50%"}



## Components 


Six main components

 - champions
 - teams
 - towers
 - minions
 - gold
 - nexus



## Champions{.center}
Before the game each player selects one of the 172 champions. Each champion has unique abilities and stats.

![](img/champions.png){width="70%"}


## Teams {.center}
Two teams compete against eachother with 5 players on each team. Each player chooses an different role.

![](img/roles.png){width="70%"}



## The Nexus {.center}
Destroy the opposing teams nexus to win the game. There are problems along the way.

![](img/nexus.png){width="15%"}



## Towers {.center}
Each team has 9 towers on their side of the map. They must be destroyed to access the Nexus but if the opponent gets too close they attack.

![](img/tower-map.png){width="50%" right-margin="100px"}
&nbsp; <!-- Adds a space between images -->
&nbsp;
![](img/tower.png){width="15%"}



## Minions {.center}

Luckily minions can be used to distract the towers from attacking the players. The minions also drop gold when eliminated.

![](img/minion.png){width="27%"}
![](img/minion-hammer.png){width="27%"}
![](img/minion-seige.png){width="27%"}



## Gold {.center}

Gold can be used to purchase items which increase the stats of the champions.

![](img/gold-pile.png){width="25%"}



## Data Size {.big-code}
Our analysis uses data from 150,000 matches of player data and 68,000 matches of team data. This means sometimes we will use screenshots from our code instead of running it live.

```{r import}
#| echo: false
match_stats <- read.csv("../data/MatchStatsTbl.csv")
row_count <- nrow(match_stats)
col_count <- ncol(match_stats)
cat("Player Data:\nThere are", row_count, "rows.\n")
cat("There are", col_count, "columns.\n\n")
```

&nbsp;

```{r import2}
team_stats <- read.csv("../data/TeamMatchTbl.csv")
row_count2 <- nrow(team_stats)
col_count2 <- ncol(team_stats)
cat("Team Data:\nThere are", row_count2, "rows.\n")
cat("There are", col_count2, "columns.\n")

library(dplyr)

summoner_match <- read.csv("../data/other/SummonerMatchTbl.csv")
match_stats <- match_stats |>
  left_join(summoner_match, by = c("SummonerMatchFk" = "SummonerMatchId"))

champions <- read.csv("../data/keys/ChampionTbl.csv")
match_stats <- match_stats |>
left_join(champions, by = c("ChampionFk" = "ChampionId"))
```



## Multiple Regression
```{r clean}

# Removes unimportant columns of data
match_stats[, c(
  "item1", "item2", "item3", "item4", "item5", "item6",
  "PrimarySlot1", "PrimarySlot2", "PrimarySlot3",
  "SecondarySlot1", "SecondarySlot2",
  "SummonerSpell1", "SummonerSpell2"
)] <- list(NULL)
```

Multiple regression to test if we can predict the damage a player has dealt knowing the damage they have taken, the gold they had, the minions they eliminated, and the amount of damage they did to turrets.
```{r sort and cycle}

library(ggplot2)
library(scales)
library(car)

# make simple regression model
multiple_regression <- lm(DmgDealt ~
    DmgTaken + TotalGold + MinionsKilled + TurretDmgDealt,
  data = match_stats
)
# Print off if this matters or not
summary(multiple_regression)
```



## Multiple Regression Graph {.big-code}
```{r multiple regression graph}
# Creates the variable plots
#000000 point color
#0.01 : 1 percent opacity

# Commented out for now
avPlots(multiple_regression, col = alpha("#000000", 0.02))
```



## Chi-square Test of Independence {.big-code}


The test determines if win rate depends on champion. 


Assumptions: 

 - Data is categorical 
 - Observations are independent 
 - Expected Frequency â‰¥ 5 



## Chi-square Test of Independence {.big-code}
We reject the null hypothesis. There is a statistically significant association between champion choice and match outcome (win/loss).

```{r Champion and Win Test for Independence}
library(dplyr)
match_stats <- read.csv("../data/MatchStatsTbl.csv")
summoner_match <- read.csv("../data/other/SummonerMatchTbl.csv")
match_stats <- match_stats |>
 left_join(summoner_match, by = c("SummonerMatchFk" = "SummonerMatchId"))
champions <- read.csv("../data/keys/ChampionTbl.csv")
match_stats <- match_stats |>
 left_join(champions, by = c("ChampionFk" = "ChampionId"))


champion_win_table <- table(match_stats$ChampionName, match_stats$Win)
chi_square_test <- chisq.test(champion_win_table)
chi_square_test
```

## Two Way Anova
```{r 2WayANOVA}
library(ggplot2)
library(dplyr)


#Definition list for each rune name and ID
rune_stones_lookup <- data.frame(
  rune = c(
    "Guardian", "SummonAery", "Electrocute", "DarkHarvest", "Conquerer",
    "ArcaneComet", "FirstStrike", "LethalTempo", "PressTheAttack",
    "Aftershock", "PhaseRush", "HailOfBlades", "FleetFootwork",
    "GlacialAugment", "GraspOfTheUndying", "UnsealedSpellbook"
  ),

  ID = c(
    "8465", "8214", "8112", "8128", "8010",
    "8229", "8369", "8008", "8005",
    "8439", "8230", "9923", "8021", "8351",
    "8437", "8360"
  ),

  tree = c(
    "Resolve1", "Sorcery1", "Domination1", "Domination2", "Precision1",
    "Sorcery2", "Inspiration1", "Precision2", "Precision3",
    "Resolve2", "Sorcery3", "Domination3", "Precision4", "Inspiration2",
    "Resolve3", "Inspiration3"
  )
)

keystone_order <- c(
  #Precision
  "Conquerer", "LethalTempo", "PressTheAttack", "FleetFootwork",
  #Domination
  "DarkHarvest", "Electrocute", "HailOfBlades",
  #Inspiration
  "GlacialAugment", "UnsealedSpellbook", "FirstStrike",
  #Sorcery
  "ArcaneComet", "SummonAery", "PhaseRush",
  #Resolve
  "GraspOfTheUndying", "Guardian", "Aftershock"
)
#Define Color Pallette for graphing and relations of color -> Rune
color_pallette <- c(
  "Precision1" = "#ffee00",
  "Precision2" = "#e2d524",
  "Precision3" = "#bbb01e",
  "Precision4" = "#8f8717",
  "Domination1" = "#af1919",
  "Domination2" = "#d81d1d",
  "Domination3" = "#811212",
  "Inspiration1" = "#267580",
  "Inspiration2" = "#36b0c0",
  "Inspiration3" = "#2c92a0",
  "Sorcery1" = "#700a8f",
  "Sorcery2" = "#8d0cb4",
  "Sorcery3" = "#5c0975",
  "Resolve1" = "#077e1b",
  "Resolve2" = "#056114",
  "Resolve3" = "#08a522"
)
rune_colors <- color_pallette[rune_stones_lookup$tree]
names(rune_colors) <- rune_stones_lookup$rune

#Filter out ourliers in data & missing data entries
#Some games have extremely high damage due to non-realistic playstyles
dmg_dealt <- match_stats$DmgDealt
q1 <- quantile(dmg_dealt, 0.25)
q3 <- quantile(dmg_dealt, 0.75)
iqr <- q3 - q1

lower_bound <- q1 - 1.5 * iqr
upper_bound <- q3 + 1.5 * iqr

filtered <- match_stats[
  dmg_dealt >= lower_bound & dmg_dealt <= upper_bound &
    match_stats$PrimaryKeyStone != "0" & match_stats$Lane != "NONE",
]

# 2 Way ANOVA on Keystone and Role
filtered$PrimaryKeyStone <- factor(filtered$PrimaryKeyStone)
filtered$Lane <- factor(filtered$Lane)
model <- aov(DmgDealt ~ PrimaryKeyStone * Lane, data = filtered)
summary(model)

# Results show a high F value meaning that KeyStone has a large
# effect on average damage even with the large amount of noise
# (random player variation still makes most of the difference)

# P-Values all very low so all very signifigant
# Residuals are very high, meaning that KeyStone and
# Lane are primarily not the biggest effects and
# most is left up to other factors
# (Likely player randomness and maybe gold earned)

#Find Individual stats
key_stone_stats <- TukeyHSD(model, "PrimaryKeyStone")
#key_stone_stats
lane_stats <- TukeyHSD(model, "Lane")
#lane_stats

# Make sure factors are properly set
filtered$PrimaryKeyStone <- factor(filtered$PrimaryKeyStone)
filtered$Lane <- factor(filtered$Lane)

#Relate Keystone ID, Name, and Colors
filtered <- filtered |>
  left_join(rune_stones_lookup, by = c("PrimaryKeyStone" = "ID"))

#Reorganizes data to group by keystone order (Domination, Precision, etc.)
filtered$rune <- factor(filtered$rune, levels = keystone_order)

#Loop over lanes and create graph for each
lanes <- unique(filtered$Lane)
```



## Top - Two Way Anova
```{r tukey-top}
df_lane <- filtered[filtered$Lane == "TOP", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("TOP") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Jungle - Two Way Anova
```{r tukey-jungle}
df_lane <- filtered[filtered$Lane == "JUNGLE", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("JUNGLE") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Middle - Two Way Anova
```{r tukey-middle}
df_lane <- filtered[filtered$Lane == "MIDDLE", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("MIDDLE") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Bottom - Two Way Anova
```{r tukey-bottom}
df_lane <- filtered[filtered$Lane == "BOTTOM", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("BOTTOM") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Support - Two Way Anova
```{r tukey-support}
df_lane <- filtered[filtered$Lane == "SUPPORT", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("SUPPORT") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Play Style Clustering
Use K-Means clustering on specific match stats. We set k = 3 and expect to see the three main styles of play get their own cluster (Jungler, Support, Laner).

Features: Damage Dealt, Damage Taken, Total Gold, Kills, Deaths, Assists, Vision Score, Dragon Kills, and Baron Kills.

```{r Play Style Clustering}
library(ggplot2)
library(reshape2)
features <- match_stats[, c("DmgDealt", "DmgTaken",
                           "TotalGold", "kills", "deaths", "assists",
                           "visionScore", "DragonKills", "BaronKills")]


#Scale features for clustering (Necessary when measuring distance)
scaled_features <- scale(features)


best <- NULL
best_wss <- Inf


for (i in 1:10){
 km_tmp <- kmeans(scaled_features, centers = 3, nstart = 25)
 if (km_tmp$tot.withinss < best_wss) {
   best = km_tmp
   best_wss = km_tmp$tot.withinss
 }
}


km <- best   # optimal run


match_stats$cluster <- km$cluster


pca <- prcomp(scaled_features)


centers <- as.data.frame(km$centers)
centers$cluster <- rownames(centers)


centers_melt <- melt(centers, id = "cluster")

cluster_graph <- ggplot(data.frame(pca$x, cluster = factor(km$cluster)),
       aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  labs(title = "Player Style Clusters (PCA Projection)")


bar_graph <- ggplot(centers_melt, aes(x = variable, y = value, fill = cluster)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Cluster Centers (Scaled Values)",
        x = "Feature", y = "Scaled Value") +
  theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
```



## Play Style Cluster Graph
```{r cluster_graph}
cluster_graph
```



## Play Style Bar Graph
```{r bar_graph}
bar_graph
```



## Chi Square Test - Build Optimizer

type here

```{r Build Optimizer}
library(dplyr)
library(tidyr)
# Pull all data from matchstats table and find the optimum
#   build and rune setup for each character.
# Where the build appears more than once.
# First Aggregate all builds that appear more than once
# Using Ahri as a proof baseline ChampID:103
library(dplyr)

# Filter to only Ahri games where the
#   Mode was not some alternate gamemode
#   (Normal Summoners Rift Only)
ahri_data <- match_stats |> filter(ChampionName == "Ahri")
ahri_data <- ahri_data |> filter(Lane != "None" & PrimaryKeyStone != 0)
ahri_wins <- sum(ahri_data$Win == 1)
total_games <- length(ahri_data$Win)

# First find if Ahris winrate is statistically signifigant
prop.test(ahri_wins, total_games)

# Prop Test shows us that Ahri's winrate is statistically different
# from the baseline of 50% by a large margin over time

test_table <- table(as.factor(ahri_data$PrimaryKeyStone), ahri_data$Win)
chisq.test(test_table)
# Ahris Winrate is signifigant between Keystones

# Find highest winrate keystone with more than 5 games played
ahri_keystone_summary <- ahri_data |>
  group_by(PrimaryKeyStone) |>
  summarise(
    games = n(),
    winrate = mean(Win)
  ) |> 
  filter(games >= 5) |>
  arrange(desc(winrate))

print(ahri_keystone_summary)
```



## Fisher Test - Build Optimizer

type here

```{r risher test}
# Is difference between them signifigant
test_table <- table(ahri_data$PrimaryKeyStone, ahri_data$Win)
fisher.test(test_table) #Alternative chi^2 because of some runes low sample size
# May be innaccurate due to nature of game

# Find best items on Ahri
# First need to aggregate item counts
unique_items <- unique(
  unlist(
    ahri_data[c(
      "item1", "item2", "item3", "item4", "item5", "item6"
    )]
  )
)

ahri_item_data <- ahri_data |>
  pivot_longer(
    cols = c(
      "item1", "item2", "item3", "item4", "item5", "item6"
    ),
    names_to = "slots",
    values_to = "item"
  )

ahri_item_summary <- ahri_item_data |>
  group_by(item) |>
  summarise(
    games = n(),
    winrate = mean(Win)
  ) |>
  filter(games >= 25) |>
  arrange(desc(winrate))

# p rint(ahri_item_summary, n = nrow(ahri_item_summary))
print(ahri_item_summary)
```

## Thank You! {.center}
![](img/league-logo.png){width="70%"}

## Questions? {.center}





