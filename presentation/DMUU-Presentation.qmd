---
title: "League of Legends Match Analysis"
author: "Logan Senol, Caleb Stanberry, Andrew Roddy"
# format: html # Test Mode
format: 
    revealjs: # Present Mode
        theme: [default, styles.scss]
        auto-stretch: true
---

## League of Legends Crash Course {.center}

What is League of Legends?


![Also known as "League" and "LoL".](img/lol-logo.png){width="50%"}



## Components 


Six main components

 - champions
 - teams
 - towers
 - minions
 - gold
 - nexus



## Champions{.center}
Before the game each player selects one of the 172 champions. Each champion has unique abilities and stats.

![](img/champions.png){width="70%"}


## Teams {.center}
Two teams compete against eachother with 5 players on each team. Each player chooses an different role.

![](img/roles.png){width="70%"}



## The Nexus {.center}
Destroy the opposing teams nexus to win the game. There are problems along the way.

![](img/nexus.png){width="15%"}



## Towers {.center}
Each team has 9 towers on their side of the map. They must be destroyed to access the Nexus but if the opponent gets too close they attack.

![](img/tower-map.png){width="50%" right-margin="100px"}
&nbsp; <!-- Adds a space between images -->
&nbsp;
![](img/tower.png){width="15%"}



## Minions {.center}

Luckily minions can be used to distract the towers from attacking the players. The minions also drop gold when eliminated.

![](img/minion.png){width="27%"}
![](img/minion-hammer.png){width="27%"}
![](img/minion-seige.png){width="27%"}



## Gold {.center}

Gold can be used to purchase items which increase the stats of the champions.

![](img/gold-pile.png){width="25%"}



## Data Size {.big-code}
Our analysis uses data from 150,000 matches of player data and 68,000 matches of team data. 
This is why our P-values may be very small and why there will be a lot of data points in the scatter plots.

```{r import}
#| echo: false
match_stats <- read.csv("../data/MatchStatsTbl.csv")
row_count <- nrow(match_stats)
col_count <- ncol(match_stats)
cat("Player Data:\nThere are", row_count, "rows.\n")
cat("There are", col_count, "columns.\n\n")
```

<!-- Basically \n -->
&nbsp; 

```{r import2}
team_stats <- read.csv("../data/TeamMatchTbl.csv")
row_count2 <- nrow(team_stats)
col_count2 <- ncol(team_stats)
cat("Team Data:\nThere are", row_count2, "rows.\n")
cat("There are", col_count2, "columns.\n")

library(dplyr)

summoner_match <- read.csv("../data/other/SummonerMatchTbl.csv")
match_stats <- match_stats |>
  left_join(summoner_match, by = c("SummonerMatchFk" = "SummonerMatchId"))

champions <- read.csv("../data/keys/ChampionTbl.csv")
match_stats <- match_stats |>
left_join(champions, by = c("ChampionFk" = "ChampionId"))
```


```{r clean}

# Removes unimportant columns of data
match_stats[, c(
  "item1", "item2", "item3", "item4", "item5", "item6",
  "PrimarySlot1", "PrimarySlot2", "PrimarySlot3",
  "SecondarySlot1", "SecondarySlot2",
  "SummonerSpell1", "SummonerSpell2"
)] <- list(NULL)
```


## Multiple Linear Regression

We use multiple linear regression to find the factors that influence damage dealt by players. 

This test finds the relationship between damage dealt and the predictors damage taken, total gold, minions killed, and towers destroyed (turret damage dealt). This test allows us to see the combined and individual effects of the continuous variables. 

## Multiple Linear Regression Assumptions
The assumptions of multiple linear regression are:

1. independence
2. linearity
3. no multicollinearity
4. normality of residuals
5. homoscedasticity

Before doing multiple linear regression we must check that all of these are true

## Independence

All 150,000 matches in out game are done in different matches. These means the outcome of the matches do not influence eachother. Because of this we know each data point is independent.

## 5 Assumptions

1. ~~independence~~
2. **linearity**
3. no multicollinearity
4. normality of residuals
5. homoscedasticity

## Linearity
To test linearity we will use `ggplot` to make scatter plots for each type of data.
We will be doing a plot of Damage Dealt against : Damage Taken, Total Gold, and Minions Killed, Turret's Destroyed. We will then visually check for linearity.

## Damage Dealt vs Damage Taken

```{r scatterplots to check for linearity taken vs dealt}
library(ggplot2)
ggplot(match_stats, aes(x = DmgTaken, y = DmgDealt)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Damage Dealt vs Damage Taken")

```

Visually linear.

## Damage Dealt vs Total Gold

```{r scatterplots to check for linearity taken vs gold}

ggplot(match_stats, aes(x = DmgTaken, y = TotalGold)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Damage Dealt vs Total Gold")

```

Visually linear.

## Damage Dealt vs Minions Killed

```{r scatterplots to check for linearity taken vs killed}

ggplot(match_stats, aes(x = DmgTaken, y = MinionsKilled)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Damage Dealt vs Minions Killed")

```

Visually not linear

## Damage Dealt vs Turrets Destroyed

```{r scatterplots to check for linearity taken vs turrets}

ggplot(match_stats, aes(x = DmgTaken, y = TurretDmgDealt)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Damage Dealt vs Turrets Destroyed")

```

Visually not linear

## Damage Dealt vs Curret Mastery Points

```{r scatterplots to check for linearity taken vs mastery points}

ggplot(match_stats, aes(x = DmgTaken, y = CurrentMasteryPoints)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Damage Dealt vs Current Mastery Points")

```

Visually not linear

## Multiple Linear Regression Conclusion

From this test we can confidently conclude that damage taken and total gold can significantly predict the amount of damage a player has dealt.

## Chi-square Test of Independence {.big-code}


The test determines if win rate depends on champion. 


Assumptions: 

 - Data is categorical 
 - Observations are independent 
 - Expected Frequency â‰¥ 5 



## Pearson Correlation Tests {.big-code}
Add Text.

```{r Pearson Correlation Tests}
match_stats <- read.csv("../data/MatchStatsTbl.csv")
summoner_match <- read.csv("../data/other/SummonerMatchTbl.csv")
match_stats <- match_stats |>
 left_join(summoner_match, by = c("SummonerMatchFk" = "SummonerMatchId"))
champions <- read.csv("../data/keys/ChampionTbl.csv")
match_stats <- match_stats |>
 left_join(champions, by = c("ChampionFk" = "ChampionId"))

# Vision Score vs Kills

cor_test_kills <- cor.test(match_stats$visionScore,
                           match_stats$kills,
                           method = "pearson")

# Scatterplot with regression line
vscore_kills_plot <- ggplot(match_stats, aes(x = visionScore, y = kills)) +
  geom_point(alpha = 0.5, color = "steelblue") +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  labs(
    title = "Vision Score vs Kills",
    subtitle = paste0("r = ", round(cor_test_kills$estimate, 3),
                      ", p = ", format.pval(cor_test_kills$p.value,
                                            digits = 3)),
    x = "Vision Score",
    y = "Kills"
  ) +
  theme_minimal()

# Vision Score vs Deaths
cor_test_deaths <- cor.test(match_stats$visionScore,
                            match_stats$deaths,
                            method = "pearson")

# Scatterplot with regression line
vscore_deaths_plot <- ggplot(match_stats, aes(x = visionScore, y = deaths)) +
  geom_point(alpha = 0.5, color = "coral") +
  geom_smooth(method = "lm", se = TRUE, color = "darkred") +
  labs(
    title = "Vision Score vs Deaths",
    subtitle = paste0("r = ", round(cor_test_deaths$estimate, 3),
                      ", p = ", format.pval(cor_test_deaths$p.value,
                                            digits = 3)),
    x = "Vision Score",
    y = "Deaths"
  ) +
  theme_minimal()
```

## Vision Score vs Kills
``` {r vision score vs kills}
vscore_kills_plot
```

## Vision Score vs Deaths
``` {r vision score vs deaths}
vscore_deaths_plot
```

## Two Way Anova
```{r 2WayANOVA}
library(ggplot2)
library(dplyr)


#Definition list for each rune name and ID
rune_stones_lookup <- data.frame(
  rune = c(
    "Guardian", "SummonAery", "Electrocute", "DarkHarvest", "Conquerer",
    "ArcaneComet", "FirstStrike", "LethalTempo", "PressTheAttack",
    "Aftershock", "PhaseRush", "HailOfBlades", "FleetFootwork",
    "GlacialAugment", "GraspOfTheUndying", "UnsealedSpellbook"
  ),

  ID = c(
    "8465", "8214", "8112", "8128", "8010",
    "8229", "8369", "8008", "8005",
    "8439", "8230", "9923", "8021", "8351",
    "8437", "8360"
  ),

  tree = c(
    "Resolve1", "Sorcery1", "Domination1", "Domination2", "Precision1",
    "Sorcery2", "Inspiration1", "Precision2", "Precision3",
    "Resolve2", "Sorcery3", "Domination3", "Precision4", "Inspiration2",
    "Resolve3", "Inspiration3"
  )
)

keystone_order <- c(
  #Precision
  "Conquerer", "LethalTempo", "PressTheAttack", "FleetFootwork",
  #Domination
  "DarkHarvest", "Electrocute", "HailOfBlades",
  #Inspiration
  "GlacialAugment", "UnsealedSpellbook", "FirstStrike",
  #Sorcery
  "ArcaneComet", "SummonAery", "PhaseRush",
  #Resolve
  "GraspOfTheUndying", "Guardian", "Aftershock"
)
#Define Color Pallette for graphing and relations of color -> Rune
color_pallette <- c(
  "Precision1" = "#ffee00",
  "Precision2" = "#e2d524",
  "Precision3" = "#bbb01e",
  "Precision4" = "#8f8717",
  "Domination1" = "#af1919",
  "Domination2" = "#d81d1d",
  "Domination3" = "#811212",
  "Inspiration1" = "#267580",
  "Inspiration2" = "#36b0c0",
  "Inspiration3" = "#2c92a0",
  "Sorcery1" = "#700a8f",
  "Sorcery2" = "#8d0cb4",
  "Sorcery3" = "#5c0975",
  "Resolve1" = "#077e1b",
  "Resolve2" = "#056114",
  "Resolve3" = "#08a522"
)
rune_colors <- color_pallette[rune_stones_lookup$tree]
names(rune_colors) <- rune_stones_lookup$rune

#Filter out ourliers in data & missing data entries
#Some games have extremely high damage due to non-realistic playstyles
dmg_dealt <- match_stats$DmgDealt
q1 <- quantile(dmg_dealt, 0.25)
q3 <- quantile(dmg_dealt, 0.75)
iqr <- q3 - q1

lower_bound <- q1 - 1.5 * iqr
upper_bound <- q3 + 1.5 * iqr

filtered <- match_stats[
  dmg_dealt >= lower_bound & dmg_dealt <= upper_bound &
    match_stats$PrimaryKeyStone != "0" & match_stats$Lane != "NONE",
]

# 2 Way ANOVA on Keystone and Role
filtered$PrimaryKeyStone <- factor(filtered$PrimaryKeyStone)
filtered$Lane <- factor(filtered$Lane)
model <- aov(DmgDealt ~ PrimaryKeyStone * Lane, data = filtered)
summary(model)

# Results show a high F value meaning that KeyStone has a large
# effect on average damage even with the large amount of noise
# (random player variation still makes most of the difference)

# P-Values all very low so all very signifigant
# Residuals are very high, meaning that KeyStone and
# Lane are primarily not the biggest effects and
# most is left up to other factors
# (Likely player randomness and maybe gold earned)

#Find Individual stats
key_stone_stats <- TukeyHSD(model, "PrimaryKeyStone")
#key_stone_stats
lane_stats <- TukeyHSD(model, "Lane")
#lane_stats

# Make sure factors are properly set
filtered$PrimaryKeyStone <- factor(filtered$PrimaryKeyStone)
filtered$Lane <- factor(filtered$Lane)

#Relate Keystone ID, Name, and Colors
filtered <- filtered |>
  left_join(rune_stones_lookup, by = c("PrimaryKeyStone" = "ID"))

#Reorganizes data to group by keystone order (Domination, Precision, etc.)
filtered$rune <- factor(filtered$rune, levels = keystone_order)

#Loop over lanes and create graph for each
lanes <- unique(filtered$Lane)
```



## Top - Two Way Anova
```{r tukey-top}
df_lane <- filtered[filtered$Lane == "TOP", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("TOP") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Jungle - Two Way Anova
```{r tukey-jungle}
df_lane <- filtered[filtered$Lane == "JUNGLE", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("JUNGLE") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Middle - Two Way Anova
```{r tukey-middle}
df_lane <- filtered[filtered$Lane == "MIDDLE", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("MIDDLE") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Bottom - Two Way Anova
```{r tukey-bottom}
df_lane <- filtered[filtered$Lane == "BOTTOM", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("BOTTOM") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Support - Two Way Anova
```{r tukey-support}
df_lane <- filtered[filtered$Lane == "SUPPORT", ]
  plot <- ggplot(df_lane, aes(x = rune, y = DmgDealt, fill = rune)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    scale_fill_manual(values = rune_colors) +
    xlab("Rune Stone") +
    ylab("Damage Dealt") +
    ggtitle("SUPPORT") +
    theme(axis.text.x = element_blank())

print(plot)
```



## Play Style Clustering
Use K-Means clustering on specific match stats. We set k = 3 and expect to see the three main styles of play get their own cluster (Jungler, Support, Laner).

Features: Damage Dealt, Damage Taken, Total Gold, Kills, Deaths, Assists, Vision Score, Dragon Kills, and Baron Kills.

```{r Play Style Clustering}
library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
library(scales)

cluster_match_stats <- match_stats |>
  filter(Lane != "NONE")

features <- cluster_match_stats[, c("DmgDealt", "DmgTaken",
                            "TotalGold", "kills", "deaths", "assists",
                            "visionScore", "DragonKills", "BaronKills")]


#Scale features for clustering (Necessary when measuring distance)
scaled_features <- scale(features)

km <- kmeans(scaled_features, centers = 3, nstart = 25)


cluster_match_stats$cluster <- km$cluster



centers <- as.data.frame(km$centers)
centers$cluster <- rownames(centers)


centers_melt <- melt(centers, id = "cluster")

play_style_bar_graph <- ggplot(
  centers_melt,
  aes(x = variable, y = value, fill = cluster)
) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Cluster Centers (Scaled Values)",
       x = "Feature", y = "Scaled Value") +
  theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))

# Prepare table
cluster_role_percent <- cluster_match_stats |>
  mutate(
    LaneGroup = case_when(
      Lane %in% c("TOP", "MIDDLE", "BOTTOM") ~ "Laner",
      Lane == "JUNGLE" ~ "Jungle",
      Lane == "SUPPORT" ~ "Support",
      TRUE ~ Lane
    )
  ) |>
  group_by(cluster, LaneGroup) |>
  summarise(count = n(), .groups = "drop") |>
  group_by(cluster) |>  # Regroup by cluster only
  mutate(percent = 100 * count / sum(count)) |>
  ungroup() |>
  select(cluster, LaneGroup, percent)

# Make stacked bar chart
cluster_comp_stacked_bar_graph <- ggplot(cluster_role_percent, 
                            aes(x = factor(cluster), y = percent,
                                fill = LaneGroup)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c(
    "Laner" = "#E69F00",      # Orange
    "Jungle" = "#009E73",    # Green
    "Support" = "#9E4CBF"     # Purple
  )) +
  scale_y_continuous(labels = percent_format(scale = 1)) +
  labs(
    title = "Lane Composition per Cluster",
    x = "Cluster",
    y = "Percentage",
    fill = "Lane Group"
  ) +
  theme_minimal()

# Pivot to wide format table
cluster_role_percent <- cluster_role_percent |>
  pivot_wider(
    names_from = LaneGroup,
    values_from = percent,
    values_fill = 0
  )
```


## Play Style Bar Graph
```{r bar_graph}
play_style_bar_graph
```

## Cluster Composition Stacked Bar Graph
```{r cluster_graph}
cluster_comp_stacked_bar_graph
```

## Team Playstyle Logistical Regression
Using a Logistical Regression test we can determine the optimal playstyle for a team based on a variety of map objectives and team kills

## Team Playstyle Logistical Regression
```{r Team Logistic Regression Function}
#Logistic Regression on a bunch of team Data
blue_barons <- team_stats$BlueBaronKillvis
blue_dragons <- team_stats$BlueDragonKills
blue_heralds <- team_stats$BlueRiftHeraldKills
blue_kills <- team_stats$BlueKills
blue_towers <- team_stats$BlueTowerKills

model <- glm(
  BlueWin ~ blue_barons + blue_dragons + blue_heralds + blue_kills + blue_towers,
  data = team_stats,
  family = binomial
)

summary(model)

```

## Team Playstyle Logistical Regression
Looking at this summary we can see the individual effects each factor has on your chance of winning. This shows that towers are by far the most important thing to be playing for as a team with dragons closly behind. Notice the negative coeffiecnt for Barons and Rift Herald takes. This is a side effect of including Tower kills in the model. As the model holds the other factors constant and tests these two it sees a lowering of winrate (Very low data size). This makes sense as these objectives are highly related to taking a tower, and thus taking this objective and failing to secure a tower signify a larger issue with the game state.

## Team Playstyle Logistical Regression
```{r Team Logistic Regression Predictor}
# Results give us a legit function,
# need to convert to individual winrate multipliers
odd_mults <- exp(coef(model)[-1])
odd_mults

#Probability Conversion = Mults/1+mult Can build predictor model off of this
winrate <- 0.5 #50% chance of winning a game
barons <- 1
dragons <- 0
heralds <- 0
kills <- 0
towers <- 1
odds <- winrate / (1 - winrate) *
  odd_mults["blue_barons"]^barons *
  odd_mults["blue_dragons"]^dragons *
  odd_mults["blue_heralds"]^heralds *
  odd_mults["blue_kills"]^kills *
  odd_mults["blue_towers"]^towers

probability <- odds / (1 + odds)
probability
```
## Thank You! {.center}
![](img/league-logo.png){width="70%"}



## Questions? {.center}
