---
title: "League of Legends Match Analysis"
author: "Logan Senol, Caleb Stanberry, Andrew Roddy"
# format: html # Test Mode
format: 
    revealjs: # Present Mode
        theme: [default, styles.scss]
        auto-stretch: true
---

## League of Legends Crash Course {.center}

What is League of Legends?


![Also known as "League" and "LoL".](img/lol-logo.png){width="50%"}



## Components 


Six main components

 - champions
 - teams
 - towers
 - minions
 - gold
 - nexus



## Champions{.center}
Before the game each player selects one of the 172 champions. Each champion has unique abilities and stats.

![](img/champions.png){width="70%"}



## Teams {.center}
Two teams compete against eachother with 5 players on each team. Each player chooses an different role.

![](img/roles.png){width="70%"}



## The Nexus {.center}
Destroy the opposing teams nexus to win the game. There are problems along the way.

![](img/nexus.png){width="15%"}



## Towers {.center}
Each team has 9 towers on their side of the map. They must be destroyed to access the Nexus but if the opponent gets too close they attack.

![](img/tower-map.png){width="50%" right-margin="100px"}
&nbsp; <!-- Adds a space between images -->
&nbsp;
![](img/tower.png){width="15%"}



## Minions {.center}

Luckily minions can be used to distract the towers from attacking the players. The minions also drop gold when eliminated.

![](img/minion.png){width="27%"}
![](img/minion-hammer.png){width="27%"}
![](img/minion-seige.png){width="27%"}



## Gold {.center}

Gold can be used to purchase items which increase the stats of the champions.

![](img/gold-pile.png){width="25%"}



## Data Size {.big-code}
Our analysis uses data from 150,000 matches of player data and 68,000 matches of team data. This means sometimes we will use screenshots from our code instead of running it live.

```{r import}
#| echo: false
match_stats <- read.csv("../data/MatchStatsTbl.csv")
row_count <- nrow(match_stats)
col_count <- ncol(match_stats)
cat("Player Data:\nThere are", row_count, "rows.\n")
cat("There are", col_count, "columns.\n\n")
```

&nbsp;

```{r import2}
team_stats <- read.csv("../data/TeamMatchTbl.csv")
row_count2 <- nrow(team_stats)
col_count2 <- ncol(team_stats)
cat("Team Data:\nThere are", row_count2, "rows.\n")
cat("There are", col_count2, "columns.\n")

library(dplyr)

summoner_match <- read.csv("../data/other/SummonerMatchTbl.csv")
match_stats <- match_stats |>
  left_join(summoner_match, by = c("SummonerMatchFk" = "SummonerMatchId"))

champions <- read.csv("../data/keys/ChampionTbl.csv")
match_stats <- match_stats |>
left_join(champions, by = c("ChampionFk" = "ChampionId"))
```



## Multiple Regression
```{r clean}

# Removes unimportant columns of data
match_stats[, c(
  "item1", "item2", "item3", "item4", "item5", "item6",
  "PrimarySlot1", "PrimarySlot2", "PrimarySlot3",
  "SecondarySlot1", "SecondarySlot2",
  "SummonerSpell1", "SummonerSpell2"
)] <- list(NULL)
```

Multiple regression to test if we can predict the damage a player has dealt knowing the damage they have taken, the gold they had, the minions they eliminated, and the amount of damage they did to turrets.
```{r sort and cycle}

library(ggplot2)
library(scales)
library(car)

# make simple regression model
multiple_regression <- lm(DmgDealt ~
    DmgTaken + TotalGold + MinionsKilled + TurretDmgDealt,
  data = match_stats
)
# Print off if this matters or not
summary(multiple_regression)
```



## Multiple Regression Graph {.big-code}
```{r multiple regression graph}
# Creates the variable plots
#000000 point color
#0.01 : 1 percent opacity

# Commented out for now
avPlots(multiple_regression, col = alpha("#000000", 0.02))
```




## Chi-square Test of Independence {.big-code}


The test determines if win rate depends on champion. 


Assumptions: 

 - Data is categorical 
 - Observations are independent 
 - Expected Frequency â‰¥ 5 




## Chi-square Test of Independence {.big-code}
We reject the null hypothesis. There is a statistically significant association between champion choice and match outcome (win/loss).

```{r Champion and Win Test for Independence}
library(dplyr)
match_stats <- read.csv("../data/MatchStatsTbl.csv")
summoner_match <- read.csv("../data/other/SummonerMatchTbl.csv")
match_stats <- match_stats |>
 left_join(summoner_match, by = c("SummonerMatchFk" = "SummonerMatchId"))
champions <- read.csv("../data/keys/ChampionTbl.csv")
match_stats <- match_stats |>
 left_join(champions, by = c("ChampionFk" = "ChampionId"))


champion_win_table <- table(match_stats$ChampionName, match_stats$Win)
chi_square_test <- chisq.test(champion_win_table)
chi_square_test
```

## Play Style Clustering
Use K-Means clustering on specific match stats. We set k = 3 and expect to see the three main styles of play get their own cluster (Jungler, Support, Laner).

Features: Damage Dealt, Damage Taken, Total Gold, Kills, Deaths, Assists, Vision Score, Dragon Kills, and Baron Kills.

```{r Play Style Clustering}
library(ggplot2)
library(reshape2)
features <- match_stats[, c("DmgDealt", "DmgTaken",
                           "TotalGold", "kills", "deaths", "assists",
                           "visionScore", "DragonKills", "BaronKills")]


#Scale features for clustering (Necessary when measuring distance)
scaled_features <- scale(features)


best <- NULL
best_wss <- Inf


for (i in 1:10){
 km_tmp <- kmeans(scaled_features, centers = 3, nstart = 25)
 if (km_tmp$tot.withinss < best_wss) {
   best = km_tmp
   best_wss = km_tmp$tot.withinss
 }
}


km <- best   # optimal run


match_stats$cluster <- km$cluster


pca <- prcomp(scaled_features)


centers <- as.data.frame(km$centers)
centers$cluster <- rownames(centers)


centers_melt <- melt(centers, id = "cluster")

ggplot(data.frame(pca$x, cluster=factor(km$cluster)),
       aes(x=PC1, y=PC2, color=cluster)) +
  geom_point(alpha=0.7) +
  theme_minimal() +
  labs(title="Player Style Clusters (PCA Projection)")

ggplot(centers_melt, aes(x = variable, y = value, fill = cluster)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Cluster Centers (Scaled Values)",
        x = "Feature", y = "Scaled Value") +
  theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
```